<html>
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <h1>The Exclusion of Women In Hollywood</h1>

    <h2>What is the Bechdel Test?</h2>
    <p>The Bechdel Test, or Bechdel-Wallace Test, sometimes called the Bechdel Rule is a simple test which names the following three criteria: (1) it has to have at least two women in it, who (2) who talk to each other, about (3) something besides a man.</p>

    <h2>Did your favorite childhood movie pass the test?</h2>
    <p>Search for it to find out.</p>
    <input></input> 


    <h2>Percentage of Movies Passing the Bechdel Test</h2>
    <p>From 1973 to 2013.</p>
    <div id="line_chart">
      <!-- This is where we will put our chart. -->
    </div>

    <h2>A Closer Look</h2>
    <p>Movie Years: </p>

    <div class="two-col">
        <div id="bubble_chart">
            <!-- This is where we will put our chart. -->
        </div>
        <div id="bubble_legend" style="width:320px;height:420px;">
            <!-- This is where we will put our chart. -->
        </div>
    </div>
    <style>
        .two-col {
            display: flex;
            flex-direction: row;
        }
    </style>

    <style>
      .selected {
        opacity: 1 !important;
        stroke: black;
        stroke-width: 1px;
      }
    </style>

    <script>
        // Load data from a URL. You can also have the json file downloaded.
        // See https://github.com/d3/d3/blob/master/API.md#fetches-d3-fetch for more options.

        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 10, bottom: 40, left: 40},
            width = 900,
            height = 450;


        // for the bubble chart
        var bubble_chart_width = 720,
            bubble_chart_height = 650,
            padding = 0.5, // separation between same-color nodes
            clusterPadding = 1; // separation between different-color nodes
           
        var w = bubble_chart_width, h = bubble_chart_height;
    
        // var color = d3.scaleOrdinal(d3.schemeCategory20);
        var centerScale = d3.scalePoint().padding(1).range([0, w]);
        var forceStrength = 5;
        
        var bubble_chart_svg = d3.select("#bubble_chart").append("svg")
            .attr("width", w)
            .attr("height", h)
        
        var bubble_legend_svg = d3.select("#bubble_legend").append("svg")
            .attr("width", 320)
            .attr("height", h)

        var simulation = d3.forceSimulation()
                .force("collide",d3.forceCollide( function(d){
                    return d.r + 2 }).iterations(20) 
                )
                .force("charge", d3.forceManyBody())
                .force("y", d3.forceY().y(h / 2))
                .force("x", d3.forceX().x(w / 2))
                .stop();
            
        bubble_chart_svg.append("text")
            .attr("x", (width / 2))             
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")  
            .style("font-size", "16px") 
            .text("Movies In Year");


        //Read the data
        d3.csv('https://raw.githubusercontent.com/fivethirtyeight/data/master/bechdel/movies.csv', d3.autoType)
          .then(function (movies) {            
            // console.log("movies", movies[0]);
            years = [];
            yearRange = [1973, 2013]
            moviesPerYear = [];
            moviesPassedPerYear =[];
            moviesPercentPassed = [];
            for (year=1973; year<=2013; year++) {
                moviesInYear = movies.filter(mov => mov.year === year);
                numMovies = moviesInYear.length;
                moviesPassedInYear = movies.filter(mov => mov.year === year && mov.binary==="PASS");
                numMoviesPassed = moviesPassedInYear.length;
                
                moviesPerYear.push(numMovies);
                moviesPassedPerYear.push(numMoviesPassed);
                moviesPercentPassed.push(numMoviesPassed/numMovies);
                movies.push(year);
            }

            const svg = d3.create('svg')
              .attr('width', width)
              .attr('height', height);
            const g = svg.append('g')
              .classed('marks', true)
              // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Add X axis --> the years
            var x = d3.scaleLinear()
              .domain([1973, 2013])
              .range([ margin.left, width-margin.right ]);
            svg.append("g")
              .classed('x-axis', true)
              .attr("transform", "translate(0," + (height - margin.bottom) + ")")
              .call(d3.axisBottom(x).tickFormat(d3.format("d")));

            var indexToYear = d3.scaleLinear()
              .domain([0, 41])
              .range([1973, 2013])

            var brushToYear = d3.scaleLinear()
              .domain([40, 870])
              .range([1973, 2013])

            var yearToIndex = d3.scaleLinear()
              .domain([1973, 2013])
              .range([0, 41])

            // Add Y axis
            var y = d3.scaleLinear()
              .domain([0, 1])
              .range([ height - margin.bottom, margin.top ]);
            svg.append("g")
              .classed('y-axis', true)
              .attr('transform', "translate("+(margin.left)+",0)")
              .call(d3.axisLeft(y).tickFormat(function (d) { return d*100 + "%" }));

            // Add the line
            svg.append("path")
              .datum(moviesPercentPassed)
              // .attr('transform', "translate(" + margin.left + ",0)")
              .attr("fill", "none")
              .attr("stroke", "steelblue")
              .attr("stroke-width", 1.5)
              .attr("d", d3.line()
                .x(function(d, i ) { return x(indexToYear(i)) })
                .y(function(d) { return y(d) })
              )

            function getDotColor(index) {
              year = indexToYear(index)
              // if (datum.hasOwnProperty("selected") && !datum.selected) {
                //   return "lightgray";
                // }
              if (Math.ceil(year) >= yearRange[0] && Math.ceil(year) <= yearRange[1]) {
                // console.log("Index", year)
                return 0.7
              }
              return 0.25;
            };

            function chartsDataJoin(rawData = gapminder) {
              dataJoin(rawData);
              // console.log(rawData, "brushed data");
              dataJoinBubble(rawData);
            };

            const symbol = d3.symbol();
            function dataJoin(rawData = movies) {
              // const data = rawData.filter(d => d.year === year);

              g.selectAll('path')
                .data(moviesPercentPassed)
                .join('path')
                .classed('country', true) // can reference these marks like css, i.e. 'path.country'
                .attr('transform', (d, i) => `translate(${x(indexToYear(i))}, ${y(d)})`)
                .attr('fill', "red")
                .attr('fill-opacity', (d, i) => getDotColor(i))
                .attr('d', d => symbol())
            }
            dataJoin(moviesPercentPassed);
              
            const brush = d3.brushX()  // Add the brush feature using the d3.brush function
              // .extent([[0, 0], [width, height]]) // wrong
              .extent([[margin.left, 0], [width, height - margin.bottom]])
              .on("start brush end", brushed)
            
            svg.select("g.marks")
              .attr("class", "brush")
              .call(brush)
              
            // 11. add brush callback to handle brush event
            let brushedData = [];
            function brushed(event) {
              const coords = event.selection;
              if (coords) {
                // const [x0, x1] = coords;
                x0 = coords[0]
                x1 = coords[1]
                // console.log("Coords", x0, x1)
                
                // augment the data with a field "selected" which is set to true only
                // for points within the brush selection
                // const brushedData = movies.map(d => {
                  //   return {
                    //     selected: Math.ceil(brushToYear(x0)) <= d.year && d.year <= Math.floor(brushToYear(x1))
                    //   };
                    // });
                yearRange = [Math.ceil(brushToYear(x0)), Math.floor(brushToYear(x1))]
              } else {
                yearRange = [1973, 2013]
              }
              brushedData = movies.filter(mov => mov.year >= yearRange[0] && mov.year <= yearRange[1])
              // console.log("Years", yearRange)

              chartsDataJoin(brushedData);
            };
              
            document.getElementById("line_chart").appendChild(svg.node());

            // BUBBLE CHART BASED ON BRUSHED DATA
            //bubble chart datajoin
            function dataJoinBubble(brushedData = []) {
            //   console.log(brushedData)
                bubble_chart_svg.selectAll('*').remove(); 
                brushedData.forEach(function(movie){
                    movie.r = Math.sqrt(movie.intgross*0.00001 / Math.PI);
                    movie.x = w / 2;
                    movie.y = h / 2;
                    var txt = document.createElement("textarea");
                    txt.innerHTML = movie.title;
                    movie.title = txt.value;
                })
                // console.log(brushedData)
                // bind nodes data to circle elements
                const elements = bubble_chart_svg.selectAll('.bubble')
                    .data(brushedData, function(d){ return d.imdb ;})
                    .enter()
                    .append('g')

                let bubbles = elements
                    .append('circle')
                    .classed('bubble', true)
                    .attr('r', d => d.r)
                    .attr('fill', d => setColor(d.binary))
                    .attr("class", function(d) { return "bubbles " + d.binary })
                    .attr("cx", function(d, i){ return 175 + 25 * i + 2 * i ** 2; })
                    .attr("cy", function(d, i){ return 250; })
                    // .style("stroke", function(d, i){ return setColor(d.binary) })
                    .style("stroke-width", 1)
                    .style("pointer-events", "all")
                    .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended))
                    // .on("click", clicked)
                    // .on("mouseover", showTooltip )
                    // .on("mousemove", moveTooltip )
                    // .on("mouseleave", hideTooltip )
                    .on("mouseover", function(event, d)  {
                      tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.8)
                      tooltip.html("Title: " + d.title + 
                                   "<br>Year: " + d.year + 
                                   "<br>Budget: " + d.budget +
                                   "<br>Grossed: " + d.domgross)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY) + "px")
                        // .style("z", 1)

                      d3.select(this)
                        .style("stroke", "black")
                    })
                    .on("mouseout", function(event, d){
                      tooltip.transition()
                        .duration(100)
                        .style("opacity", 0)
                        .style("top", "-1000px")
                        .style("left", "-1000px")
                        // .style("z", -100)

                      d3.select(this)
                        .style("stroke", setColor(d.binary))
                    })

                // labels
                let labels = elements
                    .append('text')
                    .attr('dy', '.3em')
                    .attr("class", function(d) { return "bubbles " + d.binary })
                    .style('text-anchor', 'middle')
                    .style('font-size', function(d){ return d.r >= 25 ? 10 : 0})
                    .text(d => {
                        let width = d.r * 2;
                        if (width >50 ) {
                            return d.title
                        } else {
                            return ""
                        }
                    })
                
                function ticked() {
                    bubbles
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y)
                    labels
                        .attr('x', d => d.x)
                        .attr('y', d => d.y)
                        // .each(updateText)
                }   

                simulation
                        .nodes(brushedData)
                        .on("tick", ticked);
                simulation.tick(300);
            }
            
            // function wrap(d) {
            //     var text = d3.select(this),
            //     width = d.r * 2,
            //     x = d.x,
            //     y = d.y,
            //     words = text.text().split(/\s+/).reverse(),
            //     word,
            //     line = [],
            //     lineNumber = 0,
            //     lineHeight = 1;

            //     tspan = text.text(null).append("tspan").attr("x", x).attr("y", y);
            //     if (width > 50) {
            //         while (word = words.pop()) {
            //             line.push(word);
            //             tspan.text(line.join(" "));
            //             if (tspan.node().getComputedTextLength() > width) {
            //                 line.pop();
            //                 tspan.text(line.join(" "));
            //                 line = [word];
            //                 tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + "em").text(word);
            //             }
            //         }
            //     } 
            // }

            // function updateText(d) {
            //     tspans = d3.select(this).selectAll('text > tspans');
                
            //     tspans.attr('x', d => d.x)
            //             .attr('y', d => d.y)
                    
                
            // }

            function setScale(value) {
                return Math.sqrt(value*0.00001 / Math.PI)
            }

            // Add a scale for bubble color
            function setColor(test_result) {
                return test_result =="PASS"? "#71c788" : "#db8181";
            };

            //tooltips but like for some reason none of this works
            // var tooltip = d3.select("body")
            //     .append("div")
            //     .style("opacity", 0)
            //     .attr("class", "tooltip")
            //     .style("background-color", "black")
            //     .style("border-radius", "5px")
            //     .style("padding", "10px")
            //     .style("color", "white")       
            
            // function showTooltip (d) {
            //     tooltip
            //         .transition()
            //         .duration(200)
            //     tooltip
            //         .style("opacity", 1)
            //         .html(d.title)
            //         .style("left", (()=> {
            //             // console.log(d3.pointer(event), event);
            //             // console.log((d3.pointer(event)[0]+30) + "px");
            //             return (event.pageX + "px")
            //         }))
            //         .style("top", (event.pageY-30) + "px")
            // }

            // function moveTooltip (d) {
            //     tooltip
            //     .style("left", (event.pageX) + "px")
            //     .style("top", (event.pageY-30) + "px")
            // }
            // function hideTooltip (d) {
            //     tooltip
            //     .transition()
            //     .duration(200)
            //     .style("opacity", 0)
            // }    

            var tooltip = d3.select("body").append("div")
              .attr("class", "tooltip")
              .style("opacity", 0)
            

            // legend
            var valuesToShow = [10000000, 100000000, 1000000000]
            var xCircle = 100
            var xLabel = 240
            bubble_legend_svg
                .selectAll("legend")
                .data(valuesToShow)
                .enter()
                .append("circle")
                    .attr("cx", xCircle)
                    .attr("cy", function(d){ return height - 100 - setScale(d) } )
                    .attr("r", function(d){ return setScale(d) })
                    .style("fill", "none")
                    .attr("stroke", "black")

            // Add legend: segments
            bubble_legend_svg
                .selectAll("legend")
                .data(valuesToShow)
                .enter()
                .append("line")
                    .attr('x1', function(d){ return xCircle + setScale(d)} )
                    .attr('x2', xLabel)
                    .attr('y1', function(d){ return height - 100 - setScale(d) } )
                    .attr('y2', function(d){ return height - 100 - setScale(d) } )
                    .attr('stroke', 'black')
                    .style('stroke-dasharray', ('2,2'))

            // Add legend: labels
            bubble_legend_svg
                .selectAll("legend")
                .data(valuesToShow)
                .enter()
                .append("text")
                    .attr('x', xLabel)
                    .attr('y', function(d){ return height - 100 - setScale(d) } )
                    .text( function(d){ return d/1000000 } )
                    .style("font-size", 10)
                    .attr('alignment-baseline', 'middle')

            // Legend title
            bubble_legend_svg.append("text")
                .attr('x', xCircle)
                .attr("y", height - 100 +30)
                .text("International Gross (M)")
                .attr("text-anchor", "middle")

            // Add one dot in the legend for each name.
            var size = 20
            var allgroups = ["PASS", "FAIL"]
            bubble_legend_svg.selectAll("legend_dots")
                .data(allgroups)
                .enter()
                .append("circle")
                .attr("cx", 100)
                .attr("cy", function(d,i){ return 100 + i*(size+5)}) // 100 is where the first dot appears. 25 is the distance between dots
                .attr("r", 7)
                .style("fill", function(d){
                    return setColor(d);})
                .on('mouseover', highlight)
                .on("mouseleave", noHighlight)

            // Add labels beside legend dots
            bubble_legend_svg.selectAll("mylabels")
                .data(allgroups)
                .enter()
                .append("text")
                .attr("x", 100 + size*.8)
                .attr("y", function(d,i){ return 90 + i * (size + 5) + (size/2)}) // 100 is where the first dot appears. 25 is the distance between dots
                .style("fill", function(d){ return setColor(d)})
                .text(function(d){ return d})
                .attr("text-anchor", "left")
                .style("alignment-baseline", "middle")
                .on("mouseover", highlight)
                .on("mouseleave", noHighlight)

            // What to do when one group is hovered
            function highlight (d){
                // console.log("highlight?" , d)
                // reduce opacity of all groups
                d3.selectAll(".bubbles").style("opacity", .05)
                // except the one that is hovered
                d3.selectAll("."+d.target.innerHTML).style("opacity", 1)
            }

            // And when it is not hovered anymore
            function noHighlight (d){
                d3.selectAll(".bubbles").style("opacity", 1)
            }            

            function clicked(event, d) {
                d3.select(this).transition()
                    .attr("r", d.r * 2)
                .transition()
                    .attr("r", d.r);
            }

            function dragstarted(mouse,node) {
                // console.log("dragstarted ", "movie", node, "d", mouse)
                if (!mouse.active) simulation.alpha(1).restart();
                node.fx = mouse.x;
                node.fy = mouse.y;
            }

            function dragged(mouse,node) {
                // console.log("dragged " + node)
                node.fx = mouse.x;
                node.fy = mouse.y;
            }

            function dragended(mouse,node) {
                // console.log("dragended " + node)
                if (!mouse.active) simulation.alphaTarget(0);
                node.fx = null;
                node.fy = null;
                var me = d3.select(this)
                
            } 
            
            function groupBubbles() {
                hideTitles();
                // @v4 Reset the 'x' force to draw the bubbles to the center.
                simulation.force('x', d3.forceX().strength(forceStrength).x(w / 2));

                // @v4 We can reset the alpha value and restart the simulation
                simulation.alpha(1).restart();
            }
          });
    </script>      
  </body>

  <!-- This adapted from Arvind's observable from lecture. https://observablehq.com/d/4c93c3a516d35624 -->
  <!-- Great D3 intro resource: https://observablehq.com/@d3/learn-d3?collection=@d3/learn-d3 -->
</html>
