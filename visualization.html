<html>
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
  </head>
  <body>
    <h1>Women In Hollywood</h1>
    <h2>What is the Bechdel Test?</h2>
    <p>blah </p>

    <h2>What was your favorite childhood movie?</h2>
    <input></input> 


    <h2>Line Chart</h2>
    <div id="line_chart" style="width:900px;height:400px;">
      <!-- This is where we will put our chart. -->
    </div>

    <h2>Bubble Chart</h2>
    <p>Year: 1990 (change this later on)</p>

    <div id="bubble_chart" style="width:520px;height:420px;">
        <!-- This is where we will put our chart. -->
    </div>

    <style>
      .selected {
        opacity: 1 !important;
        stroke: black;
        stroke-width: 1px;
      }
    </style>

    <script>
        // Load data from a URL. You can also have the json file downloaded.
        // See https://github.com/d3/d3/blob/master/API.md#fetches-d3-fetch for more options.

        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 60},
            width = 900 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var line_chart_svg = d3.select("#line_chart")
          .append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
          .append("g")
              .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

        //Read the data
        d3.csv('https://raw.githubusercontent.com/fivethirtyeight/data/master/bechdel/movies.csv', d3.autoType)
          .then(function (movies) {            
            console.log("movies", movies[0]);
            years = [];
            moviesPerYear = [];
            moviesPassedPerYear =[];
            moviesPercentPassed = [];
            for (year=1973; year<=2013; year++) {
                moviesInYear = movies.filter(mov => mov.year === year);
                numMovies = moviesInYear.length;
                moviesPassedInYear = movies.filter(mov => mov.year === year && mov.binary==="PASS");
                numMoviesPassed = moviesPassedInYear.length;
                
                moviesPerYear.push(numMovies);
                moviesPassedPerYear.push(numMoviesPassed);
                moviesPercentPassed.push(numMoviesPassed/numMovies);
                movies.push(year);
            }

            // Add X axis --> the years
            var x = d3.scaleLinear()
              .domain([1973, 2013])
              .range([ 0, width ]);
            line_chart_svg.append("g")
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(x).tickFormat(d3.format("d")));

            var indexToYear = d3.scaleLinear()
              .domain([0, 41])
              .range([1973, 2013])

            // Add Y axis
            var y = d3.scaleLinear()
              .domain([0, 1])
              .range([ height, 0 ]);
            line_chart_svg.append("g")
              .call(d3.axisLeft(y).tickFormat(function (d) { return d*100 + "%" }));

            // Add the line
            line_chart_svg.append("path")
              .datum(moviesPercentPassed)
              .attr("fill", "none")
              .attr("stroke", "steelblue")
              .attr("stroke-width", 1.5)
              .attr("d", d3.line()
                .x(function(d, i ) { return x(indexToYear(i)) })
                .y(function(d) { return y(d) })
              )
            
            const brush = d3.brush()  // Add the brush feature using the d3.brush function
              .extent([[0, 0], [width, height]]) // wrong
              .extent([[margin.left, 0], [width, height - margin.bottom]])
              .on("start brush end", brushed)
            
            // svg.select("g.marks")
            //   .attr("class", "brush")
            //   .call(brush)

            // 11. add brush callback to handle brush event
            function brushed(event) {
              const coords = event.selection; // [[x0, y0], [x1, y1]] for 2D brushes; [x0, x1] or [y0, y1] for 1D brushes
              if (coords) {
                const [[x0, y0], [x1, y1]] = coords;

                // augment the data with a field "selected" which is set to true only
                // for points within the brush selection
                const brushedData = gapminder.map(d => {
                  return {
                    ...d,
                    selected: x0 <= xScale(d.fertility) && xScale(d.fertility) < x1 && y0 <= yScale(d.life_expect) && yScale(d.life_expect) < y1
                  };
                });

                chartsDataJoin(brushedData);
              }
            };
          });
    </script>
    <script>
        // for the bubble chart
        var bubble_chart_width = 520,
            bubble_chart_height = 420,
            padding = 1.5, // separation between same-color nodes
            clusterPadding = 6, // separation between different-color nodes
            maxRadius = 12;
        
            var w = 520, h = 420;
    
        var radius = 25;
        // var color = d3.scaleOrdinal(d3.schemeCategory20);
        var centerScale = d3.scalePoint().padding(1).range([0, w]);
        var forceStrength = 5;
        
        var bubble_chart_svg = d3.select("#bubble_chart").append("svg")
            .attr("width", w)
            .attr("height", h)

        var simulation = d3.forceSimulation()
                .force("collide",d3.forceCollide( function(d){
                    return d.r + 8 }).iterations(16) 
                )
                .force("charge", d3.forceManyBody())
                .force("y", d3.forceY().y(h / 2))
                .force("x", d3.forceX().x(w / 2))
            
        d3.csv('https://raw.githubusercontent.com/fivethirtyeight/data/master/bechdel/movies.csv', d3.autoType)
            .then(function(movies) {
                movies = movies.filter(mov => mov.year === 1990);

                movies.forEach(function(movie){
                    movie.r = movie.intgross*0.0000001;
                    movie.x = w / 2;
                    movie.y = h / 2;
                })

                console.log(movies);

                var circles = bubble_chart_svg.selectAll("circle")
                    .data(movies, function(d){ return d.imdb ;});
                console.log("circles", circles);
                
                var circlesEnter = circles.enter().append("circle")
                    .attr("r", function(d, i){ return d.r; })
                    .attr("cx", function(d, i){ return 175 + 25 * i + 2 * i ** 2; })
                            .attr("cy", function(d, i){ return 250; })
                    .style("fill", function(d, i){ return d.binary=="PASS"? "#71c788" : "#b85b56"; })
                    .style("stroke", function(d, i){ return d.binary=="PASS"? "#71c788" : "#b85b56"; })
                    .style("stroke-width", 10)
                    .style("pointer-events", "all")
                    .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));
                
                circles = circles.merge(circlesEnter)
                
                function ticked() {
                    console.log("tick")
                    //console.log(data.map(function(d){ return d.x; }));
                    circles
                        .attr("cx", function(d){ return d.x; })
                        .attr("cy", function(d){ return d.y; });
                }   

                simulation
                        .nodes(movies)
                        .on("tick", ticked);
                
                function dragstarted(mouse,node) {
                    console.log("dragstarted ", "movie", node, "d", mouse)
                    if (!mouse.active) simulation.alpha(1).restart();
                    node.fx = mouse.x;
                    node.fy = mouse.y;
                }

                function dragged(mouse,node) {
                    // console.log("dragged " + node)
                    node.fx = mouse.x;
                    node.fy = mouse.y;
                }

                function dragended(mouse,node) {
                    // console.log("dragended " + node)
                    if (!mouse.active) simulation.alphaTarget(0);
                    node.fx = null;
                    node.fy = null;
                    var me = d3.select(this)
                    console.log(me.classed("selected"))
                    me.classed("selected", !me.classed("selected"))
                    d3.selectAll("circle")
                    .style("fill", function(d, i){ return d.binary=="PASS"? "#71c788" : "#b85b56"; })
                    
                } 
                
                function groupBubbles() {
                    hideTitles();
                    // @v4 Reset the 'x' force to draw the bubbles to the center.
                    simulation.force('x', d3.forceX().strength(forceStrength).x(w / 2));

                    // @v4 We can reset the alpha value and restart the simulation
                    simulation.alpha(1).restart();
                }
                
                // function splitBubbles(byVar) {
                    
                //     centerScale.domain(movies.map(function(d){ return d[byVar]; }));
                    
                //     if(byVar == "all"){
                //     hideTitles()
                //     } else {
                //         showTitles(byVar, centerScale);
                //     }
                    
                //     // @v4 Reset the 'x' force to draw the bubbles to their year centers
                //     simulation.force('x', d3.forceX().strength(forceStrength).x(function(d){ 
                //         return centerScale(d[byVar]);
                //     }));

                //     // @v4 We can reset the alpha value and restart the simulation
                //     simulation.alpha(2).restart();
                // }
                
                // function hideTitles() {
                //     bubble_chart_svg.selectAll('.title').remove();
                // }

                // function showTitles(byVar, scale) {
                //     // Another way to do this would be to create
                //     // the year texts once and then just hide them.
                //     var titles = bubble_chart_svg.selectAll('.title')
                //     .data(scale.domain());
                    
                //     titles.enter().append('text')
                //         .attr('class', 'title')
                //         .merge(titles)
                //         .attr('x', function (d) { return scale(d); })
                //         .attr('y', 40)
                //         .attr('text-anchor', 'middle')
                //         .text(function (d) { return byVar + ' ' + d; });
                    
                //     titles.exit().remove() 
                // }
            }
        ).catch(e => {
            console.log(e);
        });

        Array.prototype.contains = function(v) {
            for(var i = 0; i < this.length; i++) {
                if(this[i] === v) return true;
            }
            return false;
        };

      </script>
      
  </body>

  <!-- This adapted from Arvind's observable from lecture. https://observablehq.com/d/4c93c3a516d35624 -->
  <!-- Great D3 intro resource: https://observablehq.com/@d3/learn-d3?collection=@d3/learn-d3 -->
</html>
